#import "layout.typ": *

#show: academic-theme.with(
  title: "Implementation Of A GPU-Accelerated Password Cracker",
  author: "Swoyam Pokharel",
)

#pagebreak()

==== SUMMARY

```bash
.
├── docs
│   ├── images
│   │   ├── herald.png
│   │   ├── screenshots
│   │   │   ├── Screenshot from 2026-01-10 12-16-56.png
│   │   │   ├── Screenshot from 2026-01-10 12-16-58.png
│   │   │   ├── Screenshot from 2026-01-10 12-16-59.png
│   │   │   ├── Screenshot from 2026-01-10 12-17-01.png
│   │   │   ├── Screenshot from 2026-01-10 12-17-02.png
│   │   │   ├── Screenshot from 2026-01-10 12-17-03.png
│   │   │   ├── Screenshot from 2026-01-10 12-17-05.png
│   │   │   ├── Screenshot from 2026-01-10 12-17-06.png
│   │   │   ├── Screenshot from 2026-01-10 12-17-11.png
│   │   │   ├── Screenshot from 2026-01-10 12-17-12.png
│   │   │   ├── Screenshot from 2026-01-10 12-17-13.png
│   │   │   ├── Screenshot from 2026-01-10 12-17-18.png
│   │   │   ├── Screenshot from 2026-01-10 12-17-45.png
│   │   │   ├── Screenshot from 2026-01-10 12-17-47.png
│   │   │   ├── Screenshot from 2026-01-10 12-17-51.png
│   │   │   ├── Screenshot from 2026-01-10 12-17-55.png
│   │   │   ├── Screenshot from 2026-01-10 14-50-22.png
│   │   │   ├── Screenshot from 2026-01-10 14-50-29.png
│   │   │   ├── Screenshot from 2026-01-10 14-51-22.png
│   │   │   ├── Screenshot from 2026-01-10 14-51-23.png
│   │   │   └── Screenshot from 2026-01-10 14-51-24.png
│   │   └── wolverhampton.png
│   ├── layout.typ
│   ├── t3_docs.pdf
│   └── t3_docs.typ
├── outputs
│   ├── cracked_passwords.txt
│   └── passwords_encrypted.txt
└── src
    ├── cracked_passwords.txt
    ├── cracker.cu
    ├── Makefile
    ├── password_cracker
    ├── password_encrypted.txt
    ├── password_gen
    └── password_generator.c

6 directories, 35 files
```
- *`README.pdf`* contains the explaination
- *`outputs/`* contains the encryped and cracked passwords
- *`docs/`* contains the #link("https://typst.app/")[typst] source that was used to generate this `README.pdf` along with screenshots and images used in this pdf.
- *`src/`* contains the actual source code

#pagebreak()

= Program Architecture
The program implements a hybrid CPU-GPU architecture for this specific password cracking problem. Instead of repeatedly hashing all possible combinations for each target password, we generate a complete rainbow table once and then perform fast lookups against any number passwords.

== The Hybrid Approach

The architecture splits the workload between GPU and CPU based on what each does best:

- *GPU handles the transformation step*: The `cudaCrypt` function is essentially simple arithmetic operations: additions, subtractions, and wrapping logic. which is exactly what GPUs excel at, massively parallel computation.

- *CPU handles the hashing step*: SHA-512 encryption using `crypt()` is a complex cryptographic operation that can't run on CUDA cores. This stays on the CPU but gets parallelized using OpenMP across multiple CPU cores.

- *GPU handles the final search*: Once we have the rainbow table, comparing hashes against target passwords is another simple parallel operation perfect for the GPU.

== The Rainbow Table Strategy

The key idea is that the search space is known and finite: all combinations from "aa00" to "zz99" (67,600 total possibilities). 

Traditional brute-force approach would be:
```
For each target hash:
    For each of the 67,600 combinations:
        - Transform with cudaCrypt
        - Hash with SHA-512
        - Compare to target
```
This is `O(n*m)` complexity; so if we have 100 target passwords, we would be doing `6,760,000` hash operations.

A rainbow table approach:
```
One time:
    For all 67,600 combinations:
        Transform with cudaCrypt (GPU)
        Hash with SHA-512 (CPU)
        Store in rainbow table

For each target file:
    Compare target hashes to rainbow table (GPU)
```
This is `O(n + m)` complexity: we do 67,600 hash operations once, then just comparisons for any number of targets.

= Understanding The Problem
To decrypt the passwords generated by the `password_generator.c`, we first need to understand how they were created. The generator applies a specific transformation using `cudaCrypt`, then encrypts the result with SHA-512 using the `crypt()` function. Our job is to reverse this process by generating all possible combinations and finding matches.

== Understanding the encryption algorithm
The `password_generator.c` program uses the following to encrypt a 4-letter alpha-numeric string ( 2 lowercase letters + 2 digits).

```c
char* cudaCrypt(char* rawPassword) {
    static char newPassword[11];
    newPassword[0] = rawPassword[0] + 2;
    newPassword[1] = rawPassword[0] - 2;
    newPassword[2] = rawPassword[0] + 1;
    newPassword[3] = rawPassword[1] + 3;
    newPassword[4] = rawPassword[1] - 3;
    newPassword[5] = rawPassword[1] - 1;
    newPassword[6] = rawPassword[2] + 2;
    newPassword[7] = rawPassword[2] - 2;
    newPassword[8] = rawPassword[3] + 4;
    newPassword[9] = rawPassword[3] - 4;
    newPassword[10] = '\0';

    for (int i = 0; i < 10; i++) {
        if (i >= 0 && i < 6) {
            if (newPassword[i] > 122) {
                newPassword[i] = (newPassword[i] - 122) + 97;
            } else if (newPassword[i] < 97) {
                newPassword[i] = (97 - newPassword[i]) + 97;
            }
        } else { // checking number section
            if (newPassword[i] > 57) {
                newPassword[i] = (newPassword[i] - 57) + 48;
            } else if (newPassword[i] < 48) {
                newPassword[i] = (48 - newPassword[i]) + 48;
            }
        }
    }
    return newPassword;
}
```

This function, takes the `rawPassword` ( 2 lowercase letters + 2 digits) and transforms it into a 10 character encrypted password:

*Transformation logic*
- Each input character generates multiple output characters through addition/subtraction
- Input character 0 (first letter) creates output characters 0, 1, 2
- Input character 1 (second letter) creates output characters 3, 4, 5
- Input character 2 (first digit) creates output characters 6, 7
- Input character 3 (second digit) creates output characters 8, 9

*wrapping logic*
- Characters 0-5 (letters): Must stay between `a-(97)` and `z-(122)`. If they go outside this range, they wrap around.
- Characters 6-9 (digits): Must stay between `0-(48)` and `9-(57)`. If they go outside this range, they wrap around.

#pagebreak()
== Encryption Example

=== Transformation:

Let's say that `rawPassword` is `ab12`. So,

- `rawPassword[0] = 'a' => 97`
- `rawPassword[1] = 'a' => 98`
- `rawPassword[2] = '1' => 49`
- `rawPassword[3] = '2' => 50`

Now, applying these transformations:
```c
    newPassword[0] = rawPassword[0] + 2;
    newPassword[1] = rawPassword[0] - 2;
    newPassword[2] = rawPassword[0] + 1;
    newPassword[3] = rawPassword[1] + 3;
    newPassword[4] = rawPassword[1] - 3;
    newPassword[5] = rawPassword[1] - 1;
    newPassword[6] = rawPassword[2] + 2;
    newPassword[7] = rawPassword[2] - 2;
    newPassword[8] = rawPassword[3] + 4;
    newPassword[9] = rawPassword[3] - 4;
```

We get:

```c
newPassword[0] = 'a' + 2 = 97 + 2 = 99   ('c')
newPassword[1] = 'a' - 2 = 97 - 2 = 95   (exceeds the lowercase bounds)
newPassword[2] = 'a' + 1 = 97 + 1 = 98   ('b')
newPassword[3] = 'b' + 3 = 98 + 3 = 101  ('e')
newPassword[4] = 'b' - 3 = 98 - 3 = 95   (exceeds the lowercase bounds)
newPassword[5] = 'b' - 1 = 98 - 1 = 97   ('a')
newPassword[6] = '1' + 2 = 49 + 2 = 51   ('3')
newPassword[7] = '1' - 2 = 49 - 2 = 47   (exceeds the numeric bounds)
newPassword[8] = '2' + 4 = 50 + 4 = 54   ('6')
newPassword[9] = '2' - 4 = 50 - 4 = 46   (exceeds the numeric bounds)
```
=== Fixing the ones out of bounds

Now, this loop fixes the out of range values

```c
for (int i = 0; i < 10; i++) {
  if (i >= 0 && i < 6) {
    if (newPassword[i] > 122) {
      newPassword[i] = (newPassword[i] - 122) + 97;
    } else if (newPassword[i] < 97) {
      newPassword[i] = (97 - newPassword[i]) + 97;
    }
  } else { // checking number section
    if (newPassword[i] > 57) {
      newPassword[i] = (newPassword[i] - 57) + 48;
    } else if (newPassword[i] < 48) {
      newPassword[i] = (48 - newPassword[i]) + 48;
    }
  }
}
```

===== Position 1 ( value = 95, which is < 97)

```c
newPassword[1] = (97 - 95) + 97 = 2 + 97 = 99 ('c')
```

===== Position 4 ( value = 95, which is < 97)

```c
newPassword[4] = (97 - 95) + 97 = 2 + 97 = 99 ('c')
```

===== Position 7 ( value = 47, which is < 48)

```c
newPassword[7] = (48 - 47) + 48 = 1 + 48 = 49 ('1')
```

===== Position 9 (value = 46, which is < 48):

```c
newPassword[9] = (48 - 46) + 48 = 2 + 48 = 50 ('2')
```

=== Final Result
With both of those done, our final result now becomes:


```
Input: "ab12"
Output: "ccbeac3162"
```

= Data Structures

The program centers around one main data structure:

== PasswordTriple Structure

```c
typedef struct {
    char original[5];      // e.g., "aa00" 
    char transformed[11];  // 10-char transformed + null terminator
    char hashed[128];      // SHA-512 hash result (crypt output is ~100 chars)
} PasswordTriple;
```

This structure packs everything we need for each password combination into a single structure:

- *The `original` field* stores the 4-character password (plus null terminator) in the format "aa00" through "zz99". This is what we ultimately want to output when we find matches.

- *The `transformed` field* holds the result of applying the `cudaCrypt` transformation. This is the 10-character intermediate result that gets hashed. 

- *The `hashed` field* contains the final SHA-512 hash that we'll compare against target passwords.

= Converting The Encryption Function To A CUDA Program

The `cudaCrypt` transformation from the provided generator gets converted to run efficiently on the GPU, allowing us to process all 67,600 combinations in parallel.

== CUDA Encrypt
```c
__device__ void cudaEncrypt(char* rawPass, char* output) {
    output[0] = rawPass[0] + 2;
    output[1] = rawPass[0] - 2;
    output[2] = rawPass[0] + 1;
    output[3] = rawPass[1] + 3;
    output[4] = rawPass[1] - 3;
    output[5] = rawPass[1] - 1;
    output[6] = rawPass[2] + 2;
    output[7] = rawPass[2] - 2;
    output[8] = rawPass[3] + 4;
    output[9] = rawPass[3] - 4;
    output[10] = '\0';

    // Wrapping logic
    for (int i = 0; i < 10; i++) {
      if (i < 6) { // letters
        if (output[i] > 122) {
          output[i] = (output[i] - 122) + 97;
        } else if (output[i] < 97) {
          output[i] = (97 - output[i]) + 97;
        }
      } else { // digits
        if (output[i] > 57) {
          output[i] = (output[i] - 57) + 48;
        } else if (output[i] < 48) {
          output[i] = (48 - output[i]) + 48;
        }
      }
    }
}
```

This version of `cudaEncrypt` is identical to the one above, except this runs on the GPU. As such, we had to change the original `static newPassword` to instead write to the `char* output`, as to not cause race conditions amongst thousands of other CUDA threads.

Either way, this function acheives the same functionality as the `cudaCrypt` function. The `__device__` keyword tells the compiler that this can only be called from the GPU as opposed to the CPU.


= CUDA Implementation

The CUDA implementation consists of two main kernels: one for generating all possible transformations of `aa00-zz99`, and another for searching against target hashes.

== Transformed Password Generation Kernel

The `cudaCryptKernel` handles the first phase: generating all possible password combinations and applying the transformation:

```c
__global__ void cudaCryptKernel(PasswordTriple* passwords, int n)
{
    int idx = blockIdx.x * blockDim.x + threadIdx.x;

    if (idx >= n)
        return;

    // Generate the original password from index
    int digit2 = idx % 10;
    int digit1 = (idx / 10) % 10;
    int letter2 = (idx / 100) % 26;
    int letter1 = (idx / 2600) % 26;

    char rawPassword[4];
    rawPassword[0] = 'a' + letter1;
    rawPassword[1] = 'a' + letter2;
    rawPassword[2] = '0' + digit1;
    rawPassword[3] = '0' + digit2;
```

=== Index to Password Conversion

This kernel uses another approach to convert thread indices back to password combinations. Since we know the total search space is 67,600 passwords (26×26×10×10), each thread gets a unique index from 0 to 67,599, and we can reverse the original password:

The key insight:
    - The rightmost digit cycles every 1 password (0,1,2,9,0)
    - The second digit cycles every 10 passwords (after all 10 right digit values)
    - The second letter cycles every 100 passwords (after all 10*10 digit combinations)
    - The first letter cycles every 2,600 passwords (after all 26*10*10 combinations to its right)

Extraction process:
    - `idx % 10` gives the last digit (0-9); 
    - `(idx / 10) % 10` gives the second digit; divides out the last position, extracts the next
    - `(idx / 100) % 26` gives the second letter; divides out both digits (100 combinations), then finds which of 26 letters
    - `(idx / 2600) % 26 gives` the first letter; divides out all 2,600 combinations to the right, then finds which of 26 letters

Character reconstruction: Adding to 'a' or '0' converts numeric positions (0-25 or 0-9) back to actual ASCII characters.

This approach is much more efficient than having each thread iterate through combinations; each thread handles exactly one password.

=== Transformation code
Once we have the original password, the kernel applies the exact same `cudaCrypt` transformation:

```c
    // Apply transformation
    char newPassword[10];
    newPassword[0] = rawPassword[0] + 2;
    newPassword[1] = rawPassword[0] - 2;
    newPassword[2] = rawPassword[0] + 1;
    newPassword[3] = rawPassword[1] + 3;
    newPassword[4] = rawPassword[1] - 3;
    newPassword[5] = rawPassword[1] - 1;
    newPassword[6] = rawPassword[2] + 2;
    newPassword[7] = rawPassword[2] - 2;
    newPassword[8] = rawPassword[3] + 4;
    newPassword[9] = rawPassword[3] - 4;
```

The transformation logic is identical to what's in the provided `password_generator.c`, ensuring our rainbow table will match the encrypted passwords we need to crack.

== Search Kernel
The `searchHashesKernel` handles the final phase; comparing our rainbow table against target hashes:

```c
__global__ void searchHashesKernel(PasswordTriple* passwords, int n_passwords, char* target_hashes, int n_targets, int* match_indices) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;

    if (idx >= n_passwords)
        return;

    // Compare this password's hash against all target hashes
    for (int i = 0; i < n_targets; i++) {
        char* target = target_hashes + (i * MAX_HASH_LEN);
        char* candidate = passwords[idx].hashed;

        // String comparison
        bool match = true;
        for (int j = 0; j < MAX_HASH_LEN; j++) {
            if (target[j] != candidate[j]) {
                match = false;
                break;
            }
            if (target[j] == '\0' && candidate[j] == '\0') {
                break;
            }
        }

        if (match) {
            // Found a match! Store the password index at the target index
            match_indices[i] = idx;
        }
    }
}
```

Each thread takes one password from our rainbow table and compares it against all target hashes. The `match_indices` array stores the results. So, if `match_indices[i] = 1234`, it means target hash `i` matches the password at index 1234 in our rainbow table.

#pagebreak()

= CPU Hashing Implementation

While the GPU handles the parallelizable transformation and search operations, the CPU takes care of the SHA-512 hashing using OpenMP for parallelization.

== OpenMP Hashing Function

```c
void hash_transformed_passwords(PasswordTriple* passwords, int n) {
    printf("Hashing %d transformed passwords with SHA-512...\n", n);

    #pragma omp parallel
    {
        struct crypt_data data;
        data.initialized = 0;

        #pragma omp for schedule(static)
        for (int i = 0; i < n; i++) {
            // Apply crypt_r with SHA-512 (thread-safe)
            char* encrypted = crypt_r(passwords[i].transformed, SALT, &data);

            // Copy the hash result
            size_t len = 0;
            while (encrypted[len] != '\0' && len < 127) len++;
            memcpy(passwords[i].hashed, encrypted, len);
            passwords[i].hashed[len] = '\0';
        }
    }

    printf("Hashing complete!\n");
}
```

=== Why OpenMP for Hashing

The SHA-512 hashing using `crypt()` can't run on CUDA cores. However, it's still parallelizable across CPU cores:

- *Thread Safety*: We use `crypt_r()` instead of `crypt()` because it's thread-safe. Each thread gets its own `crypt_data` structure to avoid race conditions.

- *Static Scheduling*: The `schedule(static)` clause divides the work evenly among threads. 
  - Static scheduling divids the work once amongst the threads at the very beginning and requires no synchronizing later on, and thus is less overhead
  - Dynamic scheduling instead grabs small chunks from a work queue as they finish, which is better for load balancing if threads have uneven work load, but it comes at a cost of higher overhead.
  - Since in our case, the work is pretty uniform, all passwords are 10 characters long and all use the same sha512 with the same salt, static sheduling was chosen


#pagebreak()

= The Main Function

The main function orchestrates the entire hybrid workflow, coordinating between GPU and CPU operations to build the rainbow table and search for matches.

== Execution Pipeline

The program runs through six main phases:

1. Allocate memory for all 67,600 password combinations
2. Generate all combinations and apply transformation on GPU
3. Copy results back to host for SHA-512 hashing
4. Hash all transformed passwords using OpenMP on CPU
5. Copy complete rainbow table back to GPU for searching
6. Load target hashes and perform parallel search

```c
int main(int argc, char* argv[])
{
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <password_encrypted.txt>\n", argv[0]);
        return 1;
    }

    printf("Password Cracker - Generating rainbow table and searching...\n");
    printf("Total passwords: %d\n", TOTAL_PASSWORDS);

    // Allocate host memory
    PasswordTriple* h_passwords = (PasswordTriple*)malloc(TOTAL_PASSWORDS * sizeof(PasswordTriple));
    
    // Allocate device memory
    PasswordTriple* d_passwords;
    cudaMalloc(&d_passwords, TOTAL_PASSWORDS * sizeof(PasswordTriple));

    // Calculate grid dimensions
    int blocks = (TOTAL_PASSWORDS + THREADS_PER_BLOCK - 1) / THREADS_PER_BLOCK;

    printf("Generating transformations on GPU...\n");
    cudaCryptKernel<<<blocks, THREADS_PER_BLOCK>>>(d_passwords, TOTAL_PASSWORDS);
    cudaDeviceSynchronize();

    // Copy results back to host
    printf("Copying results from GPU to host...\n");
    cudaMemcpy(h_passwords, d_passwords, TOTAL_PASSWORDS * sizeof(PasswordTriple), cudaMemcpyDeviceToHost);

    // Hash the transformed passwords on CPU
    printf("Hashing transformed passwords...\n");
    hash_transformed_passwords(h_passwords, TOTAL_PASSWORDS);

    // Copy hashed passwords back to GPU
    printf("Copying hashed passwords to GPU...\n");
    cudaMemcpy(d_passwords, h_passwords, TOTAL_PASSWORDS * sizeof(PasswordTriple), cudaMemcpyHostToDevice);
```

#pagebreak()
=== Reading Encrypted Passwords

After building the complete rainbow table and copying it back to the GPU, the program loads the target hashes that need to be cracked:

```c
// Load target hashes
printf("Loading target hashes from %s...\n", argv[1]);
char* h_target_hashes = (char*)malloc(MAX_TARGETS * MAX_HASH_LEN);
int n_targets = load_target_hashes(argv[1], h_target_hashes, MAX_TARGETS);

if (n_targets <= 0) {
    fprintf(stderr, "Failed to load target hashes\n");
    cudaFree(d_passwords);
    free(h_passwords);
    free(h_target_hashes);
    return 1;
}

printf("Loaded %d target hashes\n", n_targets);
```

The `h_target_hashes` array is allocated as a flat block of memory sized to hold up to MAX_TARGETS hashes, with each hash taking up exactly MAX_HASH_LEN bytes.The `load_target_hashes` function reads the encrypted password file line by line:

```c
int load_target_hashes(const char* filename, char* hashes, int max_hashes)
{
    FILE* fp = fopen(filename, "r");
    if (!fp) {
        fprintf(stderr, "Error: Could not open %s\n", filename);
        return -1;
    }

    int count = 0;
    char line[MAX_HASH_LEN];

    while (fgets(line, sizeof(line), fp) && count < max_hashes) {
        // Remove newline
        line[strcspn(line, "\n")] = '\0';

        // Copy to hash array
        size_t len = strlen(line);
        if (len >= MAX_HASH_LEN)
            len = MAX_HASH_LEN - 1;
        memcpy(hashes + (count * MAX_HASH_LEN), line, len);
        hashes[count * MAX_HASH_LEN + len] = '\0';
        count++;
    }

    fclose(fp);
    return count;
}
```
Each line from the file gets its newline stripped using `strcspn`, which finds the first newline character and returns its position. Setting that position to `\0` removes the newline. The hash is then copied into the appropriate slot in the flat array using pointer arithmetic: `hashes + (count * MAX_HASH_LEN)` gives the starting position for hash number count.

=== GPU Transfer and Search
With targets loaded into host memory, they need to be copied to the GPU for searching:

```c
// Copy target hashes to GPU
char* d_target_hashes;
cudaMalloc(&d_target_hashes, MAX_TARGETS * MAX_HASH_LEN);
cudaMemcpy(d_target_hashes, h_target_hashes, MAX_TARGETS * MAX_HASH_LEN, cudaMemcpyHostToDevice);

// Allocate match tracking array
int* d_match_indices;
int* h_match_indices = (int*)malloc(n_targets * sizeof(int));

// Initialize to -1 (no match)
for (int i = 0; i < n_targets; i++) {
    h_match_indices[i] = -1;
}

cudaMalloc(&d_match_indices, n_targets * sizeof(int));
cudaMemcpy(d_match_indices, h_match_indices, n_targets * sizeof(int), 
           cudaMemcpyHostToDevice);
```
The `d_target_hashes` array holds the target hashes on the GPU. The `match_indices` arrays (both host and device versions) track which rainbow table entry matches each target. Initializing to `-1` lets us distinguish between "found" and "not found".
The search kernel is launched with the same grid configuration used for generating the rainbow table:

```c
printf("Searching for matches on GPU...\n");
searchHashesKernel<<<blocks, THREADS_PER_BLOCK>>>( d_passwords, TOTAL_PASSWORDS, d_target_hashes, n_targets, d_match_indices);
cudaDeviceSynchronize();

// Copy results back
cudaMemcpy(h_match_indices, d_match_indices, n_targets * sizeof(int), cudaMemcpyDeviceToHost);
```

=== Results Processing and Output

After copying match results back to the host, the program writes the passwords successfully cracked to a file:

```c
  FILE* fp = fopen("cracked_passwords.txt", "w");
  if (fp) {
    for (int i = 0; i < n_targets; i++) {
      if (h_match_indices[i] != -1) {
        int idx = h_match_indices[i];
        fprintf(fp, "%s:%s:%s\n", h_passwords[idx].hashed, h_passwords[idx].transformed, h_passwords[idx].original);
    }
  }
  fclose(fp);
  printf("Results saved to cracked_passwords.txt\n");
```

The output format is `hash:transformed:original`, showing the full chain from encrypted password back to the original plaintext. 

=== Memory Cleanup

```c
cudaFree(d_passwords);
cudaFree(d_target_hashes);
cudaFree(d_match_indices);
free(h_passwords);
free(h_target_hashes);
free(h_match_indices);

return 0;
```
All the used memory is freed after the work is done using `cudaFree` and `free` respectively.

= Compilation

To generate passwords:

```bash
[wizard@archlinux ~/Projects/School/HPC/2431342_SwoyamPokharel_6CS005/t3/src] ./password_gen
Usage: ./password_gen <number_of_passwords>
Example: ./password_gen 100
[wizard@archlinux ~/Projects/School/HPC/2431342_SwoyamPokharel_6CS005/t3/src] ./password_gen 10000
Generating 10000 encrypted passwords...
Generated 10000 passwords. Saved to password_encrypted.txt
```

To crack passwords:

```
[wizard@archlinux ~/Projects/School/HPC/2431342_SwoyamPokharel_6CS005/t3/src] make cracker
nvcc -o password_cracker cracker.cu -lcrypt -arch=sm_89 -O3 --use_fast_math -Xcompiler "-O3 -march=native -mtune=native -fopenmp -ffast-math -funroll-loops" -Xlinker -lgomp
[wizard@archlinux ~/Projects/School/HPC/2431342_SwoyamPokharel_6CS005/t3/src]
[wizard@archlinux ~/Projects/School/HPC/2431342_SwoyamPokharel_6CS005/t3/src] ./password_cracker
Usage: ./password_cracker <password_encrypted.txt>
[wizard@archlinux ~/Projects/School/HPC/2431342_SwoyamPokharel_6CS005/t3/src] ./password_cracker password_encrypted.txt
Password Cracker - Generating rainbow table and searching...
Total passwords: 67600
Generating transformations on GPU...
Copying results from GPU to host...
Hashing transformed passwords...
Hashing 67600 transformed passwords with SHA-512...
Hashing complete!
Copying hashed passwords to GPU...
Loading target hashes from password_encrypted.txt...
Loaded 10000 target hashes
Searching for matches on GPU...
Results saved to cracked_passwords.txt
[wizard@archlinux ~/Projects/School/HPC/2431342_SwoyamPokharel_6CS005/t3/src]
```

= Screenshots

#let images = (
"Screenshot from 2026-01-10 14-50-22.png",
"Screenshot from 2026-01-10 14-50-29.png",
"Screenshot from 2026-01-10 12-16-56.png",
"Screenshot from 2026-01-10 12-16-58.png",
"Screenshot from 2026-01-10 12-16-59.png",
"Screenshot from 2026-01-10 12-17-01.png",
"Screenshot from 2026-01-10 12-17-02.png",
"Screenshot from 2026-01-10 12-17-03.png",
"Screenshot from 2026-01-10 12-17-05.png",
"Screenshot from 2026-01-10 12-17-06.png",
"Screenshot from 2026-01-10 12-17-11.png",
"Screenshot from 2026-01-10 12-17-12.png",
"Screenshot from 2026-01-10 12-17-13.png",
"Screenshot from 2026-01-10 12-17-18.png",
"Screenshot from 2026-01-10 12-17-45.png",
"Screenshot from 2026-01-10 12-17-47.png",
"Screenshot from 2026-01-10 12-17-51.png",
"Screenshot from 2026-01-10 12-17-55.png",
"Screenshot from 2026-01-10 14-51-22.png",
"Screenshot from 2026-01-10 14-51-23.png",
"Screenshot from 2026-01-10 14-51-24.png",
)

#for file in images {
  image("images/screenshots/" + file)
}
